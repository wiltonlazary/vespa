// Copyright Yahoo. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.
package com.yahoo.vespa.hosted.node.admin.maintenance.coredump;

import com.yahoo.vespa.hosted.node.admin.configserver.cores.CoreDumpMetadata;
import com.yahoo.vespa.hosted.node.admin.container.ContainerOperations;
import com.yahoo.vespa.hosted.node.admin.nodeadmin.ConvergenceException;
import com.yahoo.vespa.hosted.node.admin.nodeagent.NodeAgentContext;
import com.yahoo.vespa.hosted.node.admin.task.util.fs.ContainerPath;
import com.yahoo.vespa.hosted.node.admin.task.util.process.CommandResult;

import java.nio.file.Path;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Takes in an uncompressed core dump and collects relevant metadata.
 *
 * @author freva
 */
public class CoreCollector {
    private static final Logger logger = Logger.getLogger(CoreCollector.class.getName());

    private static final Pattern JAVA_HEAP_DUMP_PATTERN = Pattern.compile("java_pid.*\\.hprof$");
    private static final Pattern CORE_GENERATOR_PATH_PATTERN = Pattern.compile("(?m)^Core was generated by `(?<path>.*?)'\\.");
    private static final Pattern EXECFN_PATH_PATTERN = Pattern.compile("^.* execfn: '(?<path>.*?)'");
    private static final Pattern FROM_PATH_PATTERN = Pattern.compile("^.* from '(?<path>.*?)'");
    static final String GDB_PATH_RHEL8 = "/opt/rh/gcc-toolset-11/root/bin/gdb";

    static final Map<String, Object> JAVA_HEAP_DUMP_METADATA =
            Map.of("bin_path", "java", "backtrace", List.of("Heap dump, no backtrace available"));

    private final ContainerOperations container;

    public CoreCollector(ContainerOperations container) {
        this.container = container;
    }

    String readBinPathFallback(NodeAgentContext context, ContainerPath coredumpPath) {
        String[] command = {GDB_PATH_RHEL8, "-n", "-batch", "-core", coredumpPath.pathInContainer()};
        CommandResult result = container.executeCommandInContainer(context, context.users().root(), command);

        Matcher matcher = CORE_GENERATOR_PATH_PATTERN.matcher(result.getOutput());
        if (! matcher.find()) {
            throw ConvergenceException.ofError(String.format("Failed to extract binary path from GDB, result: %s, command: %s",
                    asString(result), Arrays.toString(command)));
        }
        return matcher.group("path").split(" ")[0];
    }

    String readBinPath(NodeAgentContext context, ContainerPath coredumpPath) {
        String[] command = {"file", coredumpPath.pathInContainer()};
        try {
            CommandResult result = container.executeCommandInContainer(context, context.users().root(), command);
            if (result.getExitCode() != 0) {
                throw ConvergenceException.ofError("file command failed with " + asString(result));
            }

            Matcher execfnMatcher = EXECFN_PATH_PATTERN.matcher(result.getOutput());
            if (execfnMatcher.find()) {
                return execfnMatcher.group("path").split(" ")[0];
            }

            Matcher fromMatcher = FROM_PATH_PATTERN.matcher(result.getOutput());
            if (fromMatcher.find()) {
                return fromMatcher.group("path").split(" ")[0];
            }
        } catch (RuntimeException e) {
            context.log(logger, Level.WARNING, String.format("Failed getting bin path, command: %s. " +
                    "Trying fallback instead", Arrays.toString(command)), e);
        }

        return readBinPathFallback(context, coredumpPath);
    }

    List<String> readBacktrace(NodeAgentContext context, ContainerPath coredumpPath, String binPath, boolean allThreads) {
        String threads = allThreads ? "thread apply all bt" : "bt";
        String[] command = {GDB_PATH_RHEL8, "-n", "-ex", "set print frame-arguments none",
                            "-ex", threads, "-batch", binPath, coredumpPath.pathInContainer()};

        CommandResult result = container.executeCommandInContainer(context, context.users().root(), command);
        if (result.getExitCode() != 0)
            throw ConvergenceException.ofError("Failed to read backtrace " + asString(result) + ", Command: " + Arrays.toString(command));

        return List.of(result.getOutput().split("\n"));
    }

    List<String> readJstack(NodeAgentContext context, ContainerPath coredumpPath, String binPath) {
        String[] command = {"jhsdb", "jstack", "--exe", binPath, "--core", coredumpPath.pathInContainer()};

        CommandResult result = container.executeCommandInContainer(context, context.users().root(), command);
        if (result.getExitCode() != 0)
            throw ConvergenceException.ofError("Failed to read jstack " + asString(result) + ", Command: " + Arrays.toString(command));

        return List.of(result.getOutput().split("\n"));
    }

    /**
     * Collects metadata about a given core dump
     * @param context context of the NodeAgent that owns the core dump
     * @param coredumpPath path to core dump file inside the container
     * @return map of relevant metadata about the core dump
     */
    Map<String, Object> collect(NodeAgentContext context, ContainerPath coredumpPath) {
        if (JAVA_HEAP_DUMP_PATTERN.matcher(coredumpPath.getFileName().toString()).find())
            return JAVA_HEAP_DUMP_METADATA;

        Map<String, Object> data = new HashMap<>();
        try {
            String binPath = readBinPath(context, coredumpPath);

            data.put("bin_path", binPath);
            if (Path.of(binPath).getFileName().toString().equals("java")) {
                data.put("backtrace_all_threads", readJstack(context, coredumpPath, binPath));
            } else {
                data.put("backtrace", readBacktrace(context, coredumpPath, binPath, false));
                data.put("backtrace_all_threads", readBacktrace(context, coredumpPath, binPath, true));
            }
        } catch (ConvergenceException e) {
            context.log(logger, Level.WARNING, "Failed to extract backtrace: " + e.getMessage());
        } catch (RuntimeException e) {
            context.log(logger, Level.WARNING, "Failed to extract backtrace", e);
        }
        return data;
    }

    CoreDumpMetadata collect2(NodeAgentContext context, ContainerPath coredumpPath) {
        var metadata = new CoreDumpMetadata();

        if (JAVA_HEAP_DUMP_PATTERN.matcher(coredumpPath.getFileName().toString()).find()) {
            metadata.setBinPath("java")
                    .setBacktrace(List.of("Heap dump, no backtrace available"));
            return metadata;
        }

        try {
            String binPath = readBinPath(context, coredumpPath);
            metadata.setBinPath(binPath);

            if (Path.of(binPath).getFileName().toString().equals("java")) {
                metadata.setBacktraceAllThreads(readJstack(context, coredumpPath, binPath));
            } else {
                metadata.setBacktrace(readBacktrace(context, coredumpPath, binPath, false));
                metadata.setBacktraceAllThreads(readBacktrace(context, coredumpPath, binPath, true));
            }
        } catch (ConvergenceException e) {
            context.log(logger, Level.WARNING, "Failed to extract backtrace: " + e.getMessage());
        } catch (RuntimeException e) {
            context.log(logger, Level.WARNING, "Failed to extract backtrace", e);
        }
        return metadata;
    }

    private String asString(CommandResult result) {
        return "exit status " + result.getExitCode() + ", output '" + result.getOutput() + "'";
    }

}
