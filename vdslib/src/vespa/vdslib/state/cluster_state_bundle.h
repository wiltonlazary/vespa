// Copyright Yahoo. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.

#pragma once

#include <vespa/document/bucket/bucketspace.h>
#include <iosfwd>
#include <optional>
#include <string>
#include <unordered_map>
#include <memory>

namespace storage::lib {

class ClusterState;

/**
 * Class representing the baseline cluster state and the derived cluster
 * state for each bucket space.
 */
class ClusterStateBundle
{
public:

    /**
     * Represents feed blocking status of the entire cluster.
     *
     * Feed blocking only applies to client feed, and is turned on
     * when this object is present and _block_feed_in_cluster is true.
     * Feed generated by internal maintenance operations (e.g. merging) is not affected.
     */
    class FeedBlock {
    private:
        bool _block_feed_in_cluster;
        vespalib::string _description;

    public:
        FeedBlock(bool block_feed_in_cluster_in,
                  const vespalib::string& description_in);
        bool block_feed_in_cluster() const { return _block_feed_in_cluster; }
        const vespalib::string& description() const { return _description; }
        bool operator==(const FeedBlock& rhs) const;
        bool operator!=(const FeedBlock& rhs) const { return !operator==(rhs); }
    };

    using BucketSpaceStateMapping = std::unordered_map<
        document::BucketSpace,
        std::shared_ptr<const ClusterState>,
        document::BucketSpace::hash
    >;
    std::shared_ptr<const ClusterState> _baselineClusterState;
    BucketSpaceStateMapping _derivedBucketSpaceStates;
    std::optional<FeedBlock> _feed_block;
    bool _deferredActivation;
public:
    explicit ClusterStateBundle(const ClusterState &baselineClusterState);
    ClusterStateBundle(const ClusterState& baselineClusterState,
                       BucketSpaceStateMapping derivedBucketSpaceStates);
    ClusterStateBundle(const ClusterState& baselineClusterState,
                       BucketSpaceStateMapping derivedBucketSpaceStates,
                       bool deferredActivation);
    ClusterStateBundle(const ClusterState& baselineClusterState,
                       BucketSpaceStateMapping derivedBucketSpaceStates,
                       const FeedBlock& feed_block_in,
                       bool deferredActivation);

    ClusterStateBundle(const ClusterStateBundle&);
    ClusterStateBundle& operator=(const ClusterStateBundle&);
    ClusterStateBundle(ClusterStateBundle&&) noexcept;
    ClusterStateBundle& operator=(ClusterStateBundle&&) noexcept;

    ~ClusterStateBundle();
    const std::shared_ptr<const ClusterState> &getBaselineClusterState() const;
    const std::shared_ptr<const ClusterState> &getDerivedClusterState(document::BucketSpace bucketSpace) const;
    const BucketSpaceStateMapping& getDerivedClusterStates() const noexcept {
        return _derivedBucketSpaceStates;
    }
    [[nodiscard]] bool block_feed_in_cluster() const noexcept {
        return _feed_block.has_value() && _feed_block->block_feed_in_cluster();
    }
    const std::optional<FeedBlock>& feed_block() const { return _feed_block; }
    uint32_t getVersion() const;
    bool deferredActivation() const noexcept { return _deferredActivation; }
    std::string toString() const;
    bool operator==(const ClusterStateBundle &rhs) const noexcept;
    bool operator!=(const ClusterStateBundle &rhs) const noexcept { return !operator==(rhs); }
};

std::ostream& operator<<(std::ostream&, const ClusterStateBundle&);

}
